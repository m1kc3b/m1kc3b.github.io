import{C as i}from"./CallToAction-CA1CMhTF.js";import{_ as o,c as r,d as s,a as e,e as n,b as a,w as l,u as d,R as p,o as u}from"./index-DkG_yz2K.js";const m={class:"blog-post"},c={__name:"DiscoverView",setup(h){return(g,t)=>(u(),r("article",m,[t[9]||(t[9]=s('<header data-v-5ea45491><h1 data-v-5ea45491>⚡ Supercharge Your Three.js Projects with WebAssembly: A Practical Case Study</h1><p class="subtitle" data-v-5ea45491>How WebAssembly can break JavaScript performance limits and unleash new creative possibilities.</p></header><section data-v-5ea45491><h2 data-v-5ea45491>Introduction</h2><p data-v-5ea45491>Three.js has become the go-to library for creating stunning 3D experiences on the web. From immersive product showcases to generative art and interactive installations, the possibilities seem endless. But as any creative developer knows, <strong data-v-5ea45491>performance</strong> can quickly become a serious bottleneck.</p><p data-v-5ea45491>When your scene grows too complex — when you animate thousands of points, simulate physical behaviors, or process large datasets — <strong data-v-5ea45491>JavaScript&#39;s limitations</strong> start showing up: frame drops, laggy interactions, and a frustrating creative ceiling.</p><p data-v-5ea45491>Fortunately, <strong data-v-5ea45491>WebAssembly (Wasm)</strong> offers a powerful solution: it lets you write high-performance modules that <em data-v-5ea45491>work seamlessly alongside JavaScript</em>, pushing the boundaries of what&#39;s possible in real-time web graphics.</p></section><section data-v-5ea45491><h2 data-v-5ea45491>Understanding the Problem: Where JavaScript Hits Its Limits</h2><p data-v-5ea45491>JavaScript is incredibly versatile — but it&#39;s <strong data-v-5ea45491>single-threaded</strong> by design, interpreted (or JIT-compiled) at runtime, and garbage-collected.</p><p data-v-5ea45491>While engines like V8 (Chrome) and SpiderMonkey (Firefox) are insanely optimized, <strong data-v-5ea45491>pure number-crunching</strong> isn&#39;t what JavaScript was born for.</p><ul data-v-5ea45491><li data-v-5ea45491><strong data-v-5ea45491>CPU-bound calculations</strong>: Updating thousands of vertices each frame can overload the main thread.</li><li data-v-5ea45491><strong data-v-5ea45491>Real-time data transformations</strong>: Parsing large data can freeze the UI.</li><li data-v-5ea45491><strong data-v-5ea45491>Garbage collection</strong>: Can introduce unwanted frame drops.</li></ul></section>',3)),e("section",null,[t[2]||(t[2]=e("h2",null,"How WebAssembly Solves This",-1)),e("p",null,[n(d(p),{to:"/why-wasm"},{default:l(()=>t[0]||(t[0]=[e("strong",null,"WebAssembly",-1),a(" (Wasm)")])),_:1}),t[1]||(t[1]=a(" is a binary instruction format designed to run code at near-native speed in web browsers."))]),t[3]||(t[3]=e("p",null,[a("You can write modules in languages like "),e("strong",null,"Rust"),a(", compile them into Wasm, and call them from JavaScript. The benefits include:")],-1)),t[4]||(t[4]=e("ul",null,[e("li",null,[e("strong",null,"Fast math"),a(": Ideal for physics, noise, procedural generation.")]),e("li",null,[e("strong",null,"Memory control"),a(": Reduce garbage collection pressure.")]),e("li",null,[e("strong",null,"Parallelism"),a(": Leverage Web Workers and threads (where supported).")])],-1))]),t[10]||(t[10]=e("section",null,[e("h2",null,[a("Case Study: Upgrading the "),e("code",null,"webgl_points_waves"),a(" Demo")]),e("p",null,"I became interested in the example of Three.js called webgl_points_waves, which showcases a dynamic wave of particles rendered in WebGL. In this original demo, there are around 10,000 particles. However, in my WebAssembly-enhanced version, I pushed the limits and scaled it up to an impressive 1,000,000 particles. This dramatic increase in particle count demonstrates the power of WebAssembly in handling large-scale computations and rendering tasks efficiently in the browser."),e("p",null,"Feel free to interact with the iframe below and experiment with the JavaScript and WebAssembly versions by clicking the corresponding buttons. Pay close attention to the frames per second (FPS) indicator at the top-left corner of the demo. You'll notice how WebAssembly provides a smoother and more efficient performance, especially as the number of particles increases. It's a hands-on way to experience the power of WebAssembly in action and understand its impact on performance for large-scale 3D rendering tasks."),e("div",{class:"iframe-wrapper"},[e("iframe",{src:"https://m1kc3b.com/webgl_points_waves_demo/",frameborder:"0",allowfullscreen:""})]),e("p",null,"The following code examples serve as a simple illustration of how WebAssembly can be integrated into your Three.js projects. Keep in mind that these examples are just starting points, and the real power of WebAssembly lies in its seamless integration with your existing JavaScript code."),e("p",null,"With an intuitive API, incorporating WebAssembly into your workflows is straightforward, and you'll find it easy to enhance your projects with the speed and performance boost that WebAssembly provides."),e("p",null,"Whether you're working on particle simulations, physics engines, or complex 3D scenes, this integration allows you to harness the full potential of both JavaScript and WebAssembly effortlessly."),e("h3",null,"Step 1: Starting Point"),e("pre",null,[e("code",{class:"language-js"},`for (let i = 0; i < positions.length; i += 3) {
  positions[i + 1] = Math.sin(i + time) * amplitude;
}`)]),e("h3",null,"Step 2: Writing the Wasm Module in Rust"),e("pre",null,[e("code",{class:"language-rust"},`use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn update_positions(positions: &mut [f32], time: f32, amplitude: f32) {
    for i in (0..positions.len()).step_by(3) {
        positions[i + 1] = (i as f32 + time).sin() * amplitude;
    }
}`)]),e("h3",null,"Step 3: Integrating in JavaScript"),e("pre",null,[e("code",{class:"language-js"},`import init, { update_positions } from './wasm_module';

await init();

const positions = geometry.attributes.position.array;

function animate(time) {
  update_positions(positions, time * 0.001, amplitude);
  geometry.attributes.position.needsUpdate = true;
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}`)])],-1)),t[11]||(t[11]=s("<section data-v-5ea45491><h2 data-v-5ea45491>Results</h2><table data-v-5ea45491><thead data-v-5ea45491><tr data-v-5ea45491><th data-v-5ea45491></th><th data-v-5ea45491>JavaScript</th><th data-v-5ea45491>WebAssembly</th></tr></thead><tbody data-v-5ea45491><tr data-v-5ea45491><td data-v-5ea45491>Frame time (heavy load)</td><td data-v-5ea45491>~30ms</td><td data-v-5ea45491>~10ms</td></tr><tr data-v-5ea45491><td data-v-5ea45491>FPS</td><td data-v-5ea45491>30–40</td><td data-v-5ea45491>60+</td></tr><tr data-v-5ea45491><td data-v-5ea45491>Responsiveness</td><td data-v-5ea45491>UI freezes</td><td data-v-5ea45491>Smooth</td></tr><tr data-v-5ea45491><td data-v-5ea45491>Main thread usage</td><td data-v-5ea45491>High</td><td data-v-5ea45491>Low</td></tr></tbody></table></section>",1)),e("section",null,[t[5]||(t[5]=e("h2",null,"Conclusion",-1)),t[6]||(t[6]=e("p",null,[a("Three.js already makes the web a creative playground. But when performance starts limiting your imagination, "),e("strong",null,"WebAssembly becomes your secret weapon"),a(".")],-1)),t[7]||(t[7]=e("p",null,"You can integrate Wasm modules today, without rewriting your codebase, and start reaping the benefits in simulations, effects, and procedural content.",-1)),t[8]||(t[8]=e("p",null,[e("strong",null,"Need help integrating Wasm in your next Three.js project?"),a(" Let’s talk — and build something beautiful, smooth, and blazing fast.")],-1)),n(i)])]))}},f=o(c,[["__scopeId","data-v-5ea45491"]]);export{f as default};
